import{_ as e,c as s,o as a,a6 as i}from"./chunks/framework.DJOiR4ue.js";const b=JSON.parse('{"title":"Node.js全局变量","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"backend/node02.md","filePath":"backend/node02.md","lastUpdated":null}'),o={name:"backend/node02.md"},d=i('<h1 id="node-js全局变量" tabindex="-1">Node.js全局变量 <a class="header-anchor" href="#node-js全局变量" aria-label="Permalink to &quot;Node.js全局变量&quot;">​</a></h1><h2 id="定义全局变量" tabindex="-1">定义全局变量 <a class="header-anchor" href="#定义全局变量" aria-label="Permalink to &quot;定义全局变量&quot;">​</a></h2><p>在nodejs中使用<code>global</code>定义全局变量，定义的变量可以在引入的文件中也可以访问到。</p><p>例如<code>a.js</code> <code>global.xxx = &#39;xxx&#39;</code> <code>require(&#39;xxx.js&#39;)</code> xxx.js 也可以访问到该变量，在浏览器中我们定义的全局变量都在<code>window</code>，<code>Node.js</code>在<code>global</code>，不同的环境还需要判断，于是在<code>ECMAScript 2020</code> 出现了一个<code>globalThis</code>全局变量，在<code>Node.js</code>环境会自动切换成<code>global</code> ，浏览器环境自动切换<code>window</code>非常方便。</p><h2 id="关于其他全局api" tabindex="-1">关于其他全局API <a class="header-anchor" href="#关于其他全局api" aria-label="Permalink to &quot;关于其他全局API&quot;">​</a></h2><p>由于Node.js中没有DOM和BOM，除了这些API，其他的ECMAScriptAPI基本都能用</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">setTimeout setInterval </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math  console  Date </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node v18) 等</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="node-js内置全局api" tabindex="-1">Node.js内置全局API <a class="header-anchor" href="#node-js内置全局api" aria-label="Permalink to &quot;Node.js内置全局API&quot;">​</a></h2><p><code>__dirname</code> <code>__filename</code> 只能在cjs使用 esm规范没有这两个全局变量</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">__dirname  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//表示当前模块的所在目录的绝对路径</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">__filename  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//表示当前模块文件的绝对路径，包括文件名和文件扩展名</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">require </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //引入模块和模块导出详情在其他文档查看</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="process" tabindex="-1">Process <a class="header-anchor" href="#process" aria-label="Permalink to &quot;Process&quot;">​</a></h3><ol><li><p><code>process.argv</code>: 这是一个包含命令行参数的数组。第一个元素是Node.js的执行路径，第二个元素是当前执行的JavaScript文件的路径，之后的元素是传递给脚本的命令行参数。</p></li><li><p><code>process.env</code>: 这是一个包含当前环境变量的对象。您可以通过process.env访问并操作环境变量。</p></li><li><p><code>process.cwd()</code>: 这个方法返回当前工作目录的路径。</p></li><li><p><code>process.on(event, listener)</code>: 用于注册事件监听器。您可以使用process.on监听诸如exit、uncaughtException等事件，并在事件发生时执行相应的回调函数。</p></li><li><p><code>process.exit([code])</code>: 用于退出当前的Node.js进程。您可以提供一个可选的退出码作为参数。</p></li><li><p><code>process.pid</code>: 这个属性返回当前进程的PID（进程ID）。</p></li></ol><p>这些只是<code>process</code>对象的一些常用属性和方法，还有其他许多属性和方法可用于监控进程、设置信号处理、发送IPC消息等。</p><p>需要注意的是，<code>process</code>对象是一个全局对象，可以在任何模块中直接访问，无需导入或定义。</p><h3 id="buffer" tabindex="-1">buffer <a class="header-anchor" href="#buffer" aria-label="Permalink to &quot;buffer&quot;">​</a></h3><p><code>Buffer</code> 对象是 Node.js 用来处理二进制数据（如图片、视频、音频）的全局对象。</p><ol><li>创建 <code>Buffer</code> 实例：</li></ol><ul><li><p><code>Buffer.alloc(size[, fill[, encoding]])</code>: 创建一个指定大小的新的Buffer实例，初始内容为零。fill参数可用于填充缓冲区，encoding参数指定填充的字符编码。</p></li><li><p><code>Buffer.from(array)</code>: 创建一个包含给定数组的Buffer实例。</p></li><li><p><code>Buffer.from(string[, encoding])</code>: 创建一个包含给定字符串的Buffer实例。</p></li></ul><ol start="2"><li>读取和写入数据：</li></ol><ul><li><p><code>buffer[index]</code>: 通过索引读取或写入<code>Buffer</code>实例中的特定字节。</p></li><li><p><code>buffer.length</code>: 获取<code>Buffer</code>实例的字节长度。</p></li><li><p><code>buffer.toString([encoding[, start[, end]]])</code>: 将Buffer实例转换为字符串。</p></li></ul><ol start="3"><li>转换数据：</li></ol><ul><li><p><code>buffer.toJSON()</code>: 将Buffer实例转换为JSON对象。</p></li><li><p><code>buffer.slice([start[, end]])</code>: 返回一个新的Buffer实例，其中包含原始Buffer实例的部分内容。</p></li></ul><ol start="4"><li>其他方法：</li></ol><ul><li><p><code>Buffer.isBuffer(obj)</code>: 检查一个对象是否是Buffer实例。</p></li><li><p><code>Buffer.concat(list[, totalLength])</code>: 将一组Buffer实例或字节数组连接起来形成一个新的Buffer实例。</p></li></ul><p>请注意，从Node.js 6.0版本开始，<code>Buffer</code>构造函数的使用已被弃用，推荐使用<code>Buffer.alloc()</code>、<code>Buffer.from()</code>等方法来创建<code>Buffer</code>实例。</p><p><code>Buffer</code>类`在处理文件、网络通信、加密和解密等操作中非常有用，尤其是在需要处理二进制数据时。</p>',27),l=[d];function c(r,n,t,p,h,u){return a(),s("div",null,l)}const k=e(o,[["render",c]]);export{b as __pageData,k as default};
