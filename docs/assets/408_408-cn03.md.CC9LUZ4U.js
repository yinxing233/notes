import{_ as t,c as p,o as a,a6 as l}from"./chunks/framework.dE-icjW7.js";const b=JSON.parse('{"title":"http与https","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"408/408-cn03.md","filePath":"408/408-cn03.md","lastUpdated":1722009867000}'),i={name:"408/408-cn03.md"},e=l('<h1 id="http与https" tabindex="-1">http与https <a class="header-anchor" href="#http与https" aria-label="Permalink to &quot;http与https&quot;">​</a></h1><h2 id="http状态码" tabindex="-1">http状态码 <a class="header-anchor" href="#http状态码" aria-label="Permalink to &quot;http状态码&quot;">​</a></h2><h3 id="状态码分类" tabindex="-1">状态码分类 <a class="header-anchor" href="#状态码分类" aria-label="Permalink to &quot;状态码分类&quot;">​</a></h3><p>HTTP状态码是服务器在处理客户端请求后返回的3位数字，用于表示请求的处理结果。状态码分为五大类，每类都有其特定的意义：</p><ol><li><p>信息响应（100–199）：这些状态码表示请求已被接收，需要客户端继续发送请求的剩余部分。例如：</p><ul><li>100 Continue：客户端应继续发送请求。</li><li>101 Switching Protocols：服务器正在切换协议。</li></ul></li><li><p>成功响应（200–299）：这些状态码表示请求已成功处理。例如：</p><ul><li>200 OK：请求成功。</li><li>201 Created：请求成功，并且服务器创建了新的资源。</li><li>202 Accepted：服务器已接受请求，但尚未处理。</li></ul></li><li><p>重定向（300–399）：这些状态码表示需要进一步操作以完成请求。例如：</p><ul><li>301 Moved Permanently：请求的资源已永久移动到新位置。</li><li>302 Found：请求的资源临时移动到新位置。</li><li>304 Not Modified：客户端已缓存的资源未发生变化。</li></ul></li><li><p>客户端错误响应（400–499）：这些状态码表示请求包含语法错误或无法完成。例如：</p><ul><li>400 Bad Request：服务器无法理解请求。</li><li>401 Unauthorized：请求需要用户验证。</li><li>403 Forbidden：服务器拒绝请求。</li><li>404 Not Found：请求的资源在服务器上不存在。</li></ul></li><li><p>服务器错误响应（500–599）：这些状态码表示服务器在处理请求时遇到了错误。例如：</p><ul><li>500 Internal Server Error：服务器内部错误。</li><li>501 Not Implemented：这个状态码表示服务器不支持客户端请求的方法。也就是说，服务器理解了请求，但无法执行请求中指定的方法。这种情况通常发生在服务器尚未实现请求的特定功能时。</li><li>502 Bad Gateway：这个状态码表示服务器作为网关或代理时，从上游服务器（即服务器试图访问的服务器）收到了无效的响应。这可能是因为上游服务器遇到了问题，或者网络连接存在问题。</li><li>503 Service Unavailable：服务器暂时无法处理请求。</li><li>504 Gateway Timeout：这个状态码表示服务器作为网关或代理时，没有在合理的时间内从上游服务器接收到响应。这通常意味着上游服务器没有在规定的时间内响应请求，导致网关服务器超时。</li></ul></li></ol><h3 id="_301和302有什么区别" tabindex="-1">301和302有什么区别？ <a class="header-anchor" href="#_301和302有什么区别" aria-label="Permalink to &quot;301和302有什么区别？&quot;">​</a></h3><p>HTTP状态码301和302都是重定向状态码，它们指示客户端浏览器应该访问一个新的URL地址。主要区别在于重定向的永久性和请求方法的处理方式。</p><ul><li><p>301 Moved Permanently：表示请求的资源已经被永久移动到新的URL。当服务器返回这个状态码时，它会在响应头中包含一个新的URL（Location），浏览器会自动跳转到这个新的地址。对于搜索引擎优化（SEO）来说，301重定向会传递旧URL的权重到新URL，这对于网站迁移或域名更换时保持搜索引擎排名尤为重要。</p></li><li><p>302 Found：表示请求的资源临时移动到新的URL。与301类似，服务器也会在响应头中包含新的URL，浏览器会跳转到这个地址。但是，302重定向不会传递旧URL的权重到新URL，搜索引擎会继续索引旧URL。这意味着，如果资源只是临时移动，使用302是合适的。</p></li></ul><p>在实际应用中，如果资源的移动是永久性的，应该使用301；如果资源只是临时移动，例如网站维护或内容更新，那么应该使用302。此外，301重定向通常用于网站迁移、域名变更等长期变化，而302重定向则用于临时的URL更改。</p><h3 id="_304的过程" tabindex="-1">304的过程 <a class="header-anchor" href="#_304的过程" aria-label="Permalink to &quot;304的过程&quot;">​</a></h3><p>HTTP状态码304 Not Modified表示客户端已经缓存了请求的资源，并且该资源自从上次请求以来没有发生任何变化。这个状态码通常与条件请求（Conditional Request）一起使用，例如使用If-Modified-Since或If-None-Match头部。以下是状态码304请求过程的详细步骤：</p><ol><li><p>客户端缓存检查：客户端（如浏览器）首先检查本地缓存，看是否有请求资源的副本，以及该副本的有效期。</p></li><li><p>条件请求：如果客户端发现有缓存的资源，并且资源的缓存时间尚未过期，它会发送一个带有条件头部的请求到服务器。这些条件头部可以是If-Modified-Since（指定上次修改时间）或If-None-Match（指定资源的ETag值）。</p></li><li><p>服务器验证：服务器接收到请求后，会根据条件头部中的信息验证资源是否有所更新。服务器会检查资源的最后修改时间或ETag值，与客户端提供的值进行比较。</p></li><li><p>资源未修改：如果服务器发现资源自上次客户端请求以来没有变化，它会返回状态码304，并可能包含一些响应头，如Last-Modified（资源最后修改时间）或ETag（资源的唯一标识符）。</p></li><li><p>客户端使用缓存：客户端收到304响应后，知道服务器上的资源没有变化，因此不会下载任何内容。客户端会使用本地缓存的资源副本来响应用户的请求。</p></li><li><p>更新缓存信息：客户端可能会更新缓存的有效时间，以便在未来的请求中使用相同的逻辑。</p></li><li><p>客户端渲染页面：客户端使用缓存的资源来渲染页面，用户感知不到任何额外的加载过程。</p></li></ol><p>整个过程中，状态码304的请求和响应都不会包含资源的主体内容，因为客户端已经有了资源的最新版本。这种机制可以减少网络带宽的使用，加快页面加载速度，并提高用户体验。</p><h2 id="https" tabindex="-1">https <a class="header-anchor" href="#https" aria-label="Permalink to &quot;https&quot;">​</a></h2><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h3><p>网络协议：设备通信的规则集合</p><p><code>tcp</code>：传输层协议，规定数据传输的方式，有连接的全双工通信，与udp对比，三次握手</p><p><code>http</code>：应用层协议，规定传输内容的格式，请求 → 响应的通信模式</p><p><strong>数据通信，信息加解密 信息摘要 编码</strong></p><p>数据通信：数据信息经由网络在设备之间的传递</p><p>保密通信：只有通信双方可以获取传递的信息</p><p>加密：（<code>https</code>加密，<code>md5</code>加密，<code>base64</code>加密）信息加密（明文 密文），信息摘要，编码的区别</p><p>举例：信息加密（替换法加密，换位法加密，秘钥）；信息摘要（<code>md5</code>，签名）；编码（<code>base64</code>编码，<code>url</code>编码）</p><p><strong>对称加密和非对称加密</strong></p><p>对称加密：加密和解密的秘钥相同，加密是解密的逆过程</p><p>非对称加密：加密和解密的秘钥不同</p><h3 id="关于https" tabindex="-1">关于https <a class="header-anchor" href="#关于https" aria-label="Permalink to &quot;关于https&quot;">​</a></h3><p><strong>场景：网络数据通信要解决的问题——保密 &amp; 信任</strong></p><p>保密：为保证两人之间的网络通信内容不为外人所知，信息发送方要对信息加密，接收方解密</p><p>信任：确保网络信息发送者就是生成的那个人</p><p>对称加密无法解决这两个问题</p><p><strong>解决方法：公钥密码系统</strong></p><p>公钥密码系统使用非对称加密的加密方法</p><p>公钥和私钥：公钥加密信息必须对应的私钥解密，私钥加密信息必须对应的公钥解密</p><p>解决保密问题：如果使用对称加密算法，秘钥的可靠传递是一个问题。使用公钥密码系统可以很好地解决这个问题，如果甲要向乙发送保密信息，甲可以用乙的公钥加密信息，然后发送给乙，乙用自己的私钥就可以解密信息，由于别人没有乙的私钥，所以信息的原文不会被别人看到。所以为了确保通信的保密性，信息都是使用公钥加密，私钥解密</p><p>解决信任问题：如果甲想要给其他人发送信息，可以先用自己的私钥加密消息。这样，信息的接收方可以用甲的公钥解密，这就保证了信息不被篡改，因为如果信息被别人篡改，使用甲的公钥就无法成功解密</p><p>举例：git的ssl</p><h3 id="https原理" tabindex="-1">https原理 <a class="header-anchor" href="#https原理" aria-label="Permalink to &quot;https原理&quot;">​</a></h3><p>https协议中使用了公钥加密系统，但并不是使用非对称加密方法直接对通信信息直接加密，而是利用非对称加密算法传递对称加密算法的秘钥。更具体地说，使用https进行通信的客户端和服务器的主要通信过程是这样的</p><ul><li>服务器维护自己的私钥，服务器将自己的公钥发送给客户端</li><li>客户端用服务器的公钥加密对称加密的秘钥，并发送给服务器</li><li>服务器用私钥解密信息，得到对称加密的秘钥，之后客户端和服务器使用对称加密秘钥进行保密通信</li></ul><p>为什么要这么做呢？</p><p>首先，由于非对称加密秘钥的可靠传递问题，我们不能直接使用非对称加密进行通信</p><p>如果使用非对称加密，通常的思路是，客户端和服务器各维护自己的私钥，建立连接时，客户端发送给服务器自己的公钥，服务器再把自己的公钥用客户端公钥加密传递给客户端，这样就建立好了连接，客户端和服务器之间可以用服务器的公钥-私钥进行保密通信。如果在建立连接阶段被中间人劫持，连接不会正常被建立，在建立好连接之后，则被劫持到数据包也无法解析出明文。但是，非对称加密相对对称加密性能较低，因此我们不能直接使用非对称加密进行通信</p><p>因此，https实际的通信使用了比较巧妙的方法，即实际通信还是使用对称加密。使用非对称加密对对称加密秘钥进行可靠传递</p><p>秘钥传递的时机：在tcp握手时进行传递，这样可以在连接建立后，就做好了进行保密通信的准备，这样，如果能成功建立tcp连接，就成功建立了ssl通道</p><h3 id="https通信流程" tabindex="-1">https通信流程 <a class="header-anchor" href="#https通信流程" aria-label="Permalink to &quot;https通信流程&quot;">​</a></h3><p><strong>约定非对称加密算法及hash算法</strong></p><ol><li>客户端→服务器</li></ol><p>客户端将自己支持的一套加密规则（包括对称加密算法和hash算法）发送给服务器</p><ol start="2"><li>服务器→客户端</li></ol><p>选定对称加密和hash算法</p><p>服务器将选定的算法和公钥发送给客户端</p><p><strong>传递非对称加密秘钥</strong></p><ol start="3"><li>客户端→服务器</li></ol><p>生成随机数秘钥（对称加密秘钥），并用公钥加密，得到加密后的随机数</p><p>计算握手消息</p><p>用随机数对握手消息加密，得到加密后的握手消息</p><p>用约定好的hash算法计算握手消息，得到hash后的握手消息</p><p>客户端将加密后的随机数、加密后的握手消息、hash后的握手消息发送到服务器</p><ol start="4"><li>服务器→客户端</li></ol><p>用私钥解密随机数</p><p>用随机数解密握手消息</p><p>验证hash后的握手消息与客户端发来的hash是否一致</p><p>用随机数加密一段握手消息</p><p>用hash加密握手消息</p><p>服务器将加密后的握手消息和hash后的握手消息发送给客户端</p><ol start="5"><li>客户端→服务器</li></ol><p>客户端解密握手消息并验证hash一致</p><p>客户端用随机数加密握手消息</p><p>用hash加密握手消息</p><p>客户端将加密后的握手消息和hash后的握手消息发送给服务器</p><p>握手结束，客户端开始向服务器发送通信信息（使用随机数进行通信）</p><h3 id="证书" tabindex="-1">证书 <a class="header-anchor" href="#证书" aria-label="Permalink to &quot;证书&quot;">​</a></h3><p>信任问题，网络通信中的信任问题主要是客户端对服务器的信任问题，即客户端希望保证它访问的服务器就是它想访问的服务器（服务器对客户端的信任问题则无关痛痒）。</p><p>之前已经提到，使用公钥加密系统可以解决信任问题。 由于私钥加密的密文只有公钥可以解密，假设客户端有某个服务器的公钥，那么如果加密的信息能够使用公钥解密，说明这条信息是由该服务器发出的。</p><p>客户端如何保证自己拿到的服务器的公钥就是这个服务器的公钥，而不是攻击者盗用的公钥呢？</p><p>这一点通过权威的第三方证明来保证，就像淘宝平台如何解决买家对卖家的信任问题？答案是借助淘宝这个权威第三方平台。服务器需要向证书的颁发机构申请证书，通过证书来证明自己的身份，这就是ssl证书的作用，下面简称证书。</p><p>证书提供了公钥-私钥对，和域名与公钥绑定关系的证明。</p><p>服务器安装了证书后，就可以证明自己的身份了，在https通信时，客户端接收到服务器发送的证书后会去验证证书的绑定域名是否与当前访问域名一致，一致则可以确认网站身份。</p><h3 id="https相关问题" tabindex="-1">https相关问题 <a class="header-anchor" href="#https相关问题" aria-label="Permalink to &quot;https相关问题&quot;">​</a></h3><p><strong>什么是https，与http的关系</strong></p><p>https是一个基于http的保密通信协议，它在http基础上增加了一个安全套接层，https由于需要在通信过程中进行加密解密，因此性能低于http，当然安全性高于http。在https网页中发送http的ajax请求将会被浏览器block，因为浏览器认为这是不安全的操作，而在http网页中发送https请求是被允许的。</p><p><strong>为什么需要https</strong></p><p>https保证数据以更保密的方式传输，并增加对服务器身份验证，这可以使我们的数据传输更安全，有效防止数据的泄露和篡改</p><p><strong>https是怎么防止DNS劫持和钓鱼网站的</strong></p><p>DNS劫持，即将用户访问的域名指定到攻击者的服务器的攻击方法。如果正常的网站使用https，那么客户端会验证证书，而由于证书审核很严格并且较难伪造，所以攻击者的服务器不太可能会有一个权威机构颁发的证书，因此无法和浏览器建立连接</p><p>钓鱼网站，即仿冒正常网站的网站，目的是欺骗用户，获取敏感信息。钓鱼网站也很难获得合法的证书，因此不容易仿冒使用https的网站</p><p><strong>https是怎么进行通信的</strong></p><p>见上一小节。</p><p><strong>什么是证书，证书的作用</strong></p><p>ssl证书是一个文件，是数字证书的一种</p><p>它部署在服务器上，可以给服务器提供进行https通信的支持，提供公钥和私钥用于保密通信，并提供身份认证确保服务器可信。</p>',92),h=[e];function o(s,r,n,d,c,u){return a(),p("div",null,h)}const f=t(i,[["render",o]]);export{b as __pageData,f as default};
